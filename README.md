#### 1. Вопросы для разогрева
>Расскажите, с какими задачами в направлении безопасной разработки вы сталкивались?

- Использование протоколов HTTPS вместо HTTP.
- Шифрование данных(пароли)
- Защита от подделки межсайтовых запросов (CSRF)
- Валидация входных данных
- Аутентификация и авторизация
- Ограничение сессий
- Мониторинг
- Резервное копирование

Вроде по логике все это можно отнести к базовым вещам по безопасности в веб приложениях.

> Если вам приходилось проводить security code review или моделирование угроз, расскажите, как это было?

Ревью по безопасности делать не приходилось, максимум при обучении на совместном проекте делали код ревью друг другу, нужно было смотреть на сколько жесткая валидация входных данных.


> Если у вас был опыт поиска уязвимостей, расскажите, как это было?

В сети интернет такого опыта не было, а в физическом мире был (дипломный проект основывался на поиске всевозможных способов каналов утечки информации с конкретного помещения и способы предотвращения этому).


> Почему вы хотите участвовать в стажировке?


Так сложилось, что я работал помощником сетевого инженера, прошёл курсы python разработчика, закончил ВУЗ на факультете информационной безопасности, со времен университета все время в ИТ... Я думаю, все эти факторы могут быть хорошим фундаментом для данной специальности.



#### 2. Security code review
##### Часть 1. Security code review: GO
> Требуется провести анализ кода на GO с точки зрения безопасности и подготовить отчет по следующим пунктам:

> Какие уязвимости присутствуют в этом фрагменте кода?
Указать строки, в которых присутствуют уязвимости.
К каким последствиям может привести эксплуатация найденных уязвимостей злоумышленником?
Описать способы исправления уязвимостей.
Если уязвимость можно исправить несколькими способами, необходимо перечислить их, выбрать лучший по вашему мнению и аргументировать свой выбор.
package main
```go
import (
    "database/sql"
    "fmt"
    "log"
    "net/http"
    "github.com/go-sql-driver/mysql"
)

var db *sql.DB
var err error

func initDB() {
    db, err = sql.Open("mysql", "user:password@/dbname")
    if err != nil {
        log.Fatal(err)
    }

err = db.Ping()
if err != nil {
    log.Fatal(err)
    }
}

func searchHandler(w http.ResponseWriter, r *http.Request) {
    if r.Method != "GET" {
        http.Error(w, "Method is not supported.", http.StatusNotFound)
        return
    }

searchQuery := r.URL.Query().Get("query")
if searchQuery == "" {
    http.Error(w, "Query parameter is missing", http.StatusBadRequest)
    return
}

query := fmt.Sprintf("SELECT * FROM products WHERE name LIKE '%%%s%%'", searchQuery)
rows, err := db.Query(query)
if err != nil {
    http.Error(w, "Query failed", http.StatusInternalServerError)
    log.Println(err)
    return
}
defer rows.Close()

var products []string
for rows.Next() {
    var name string
    err := rows.Scan(&name)
    if err != nil {
        log.Fatal(err)
    }
    products = append(products, name)
}

fmt.Fprintf(w, "Found products: %v\n", products)
}

func main() {
    initDB()
    defer db.Close()

http.HandleFunc("/search", searchHandler)
fmt.Println("Server is running")
log.Fatal(http.ListenAndServe(":8080", nil))
}
```

- **Ответ**:

Я с языком GO не знаком, но почитав несколько статей с примерами на хабре про самые частые уязвимости в GO, попробую указать на несколько ошибок:
1. SQL Injection в строке:
```
query := fmt.Sprintf("SELECT * FROM products WHERE name LIKE '%%%s%%'", searchQuery)
rows, err := db.Query(query)
```
Здесь используется конкатенация строки searchQuery напрямую в SQL-запросе,что позволяет внедрить сюда SQL-инъекцию. Это позволяет выполнить произвольный SQL-код с доступом к данным в БД.
Нужно параметризировать запрос.
```
  query := "SELECT * FROM products WHERE name LIKE ?"
  rows, err := db.Query(query, "%"+searchQuery+"%")
```
2. Такие данные лучше в переменные окружения или отдельный конфиг файл:
```
db, err = sql.Open("mysql", "user:password@/dbname")
```
3. Возможно еще нужно более серьезно обрабатывать ошибки при подключении к БД.



##### Часть 2: Security code review: Python

>Требуется определить тип уязвимости в примерах кода на Python и ответить на следующие вопросы:

>Указать строки, в которых присутствуют уязвимости.
К каким последствиям может привести эксплуатация данных уязвимостей злоумышленником?
Описать способы исправления уязвимостей.
Если уязвимость можно исправить несколькими способами, необходимо перечислить их, выбрать лучший по вашему мнению и аргументировать свой выбор.
Пример №2.1
```
from flask import Flask, request
from jinja2 import Template

app = Flask(name)

@app.route("/page")
def page():
    name = request.values.get('name')
    age = request.values.get('age', 'unknown')
    output = Template('Hello ' + name + '! Your age is ' + age + '.').render()
return output

if name == "main":
    app.run(debug=True)
```
>Пример №2.2
```
from flask import Flask, request
import subprocess

app = Flask(name)

@app.route("/dns")
def dns_lookup():
    hostname = request.values.get('hostname')
    cmd = 'nslookup ' + hostname
    output = subprocess.check_output(cmd, shell=True, text=True)
return output
if name == "main":
    app.run(debug=True)
```
---------------------------
**Ответ для Примера №2.1:** 

- Во-первых, код работать не будет изза того что строка ``return output`` не отбита 4 пробелами(допустим, что опечатка, идем дальше.)

- Строка ``output = Template('Hello ' + name + '! Your age is ' + age + '.').render()`` является уязвимой.
- Здесь уязвимость Server-Side Template Injection (SSTI) - это позволяет внедрить сторонний код в наш код. Смогут, как минимум, получить конфиденциальные данные, также удаленно выполнить код на нашем сервере.

``http://localhost:5000/page?name={{5*5}}&age={{6*6}}``   получаем вывод: ``Hello 25! Your age is 36.``
Получается, можно исполнить скрипт внутри нашего сервера.

**Как исправить:** 
1. использовать безопасный синтаксис шаблонизации с автоматическим экранированием:

```
output = Template('Hello {{ name }}! Your age is {{ age }}.').render(name=name, age=age)
```
2. Использование markupsafe вместо jinja2 для экранирования
  ```
  name = escape(request.values.get("name", ""))
  age = escape(request.values.get("age", "unknown"))
  output = Markup("Hello %s! Your age is %s." % (name, age))
  ```
- При таком подходе:
``http://localhost:5000/page?name={{5*5}}&age={{6*6}}``  получу вывод: ``Hello {{5*5}}! Your age is {{6*6}}.``
Вижу, что код не исполняется.

- На мой взгляд, здесь первый вариант решения лучше так как не нужно дополнительных интеграций и вообще **"Третий пункт Дзен Python - "Simple is better than complex."**.:))"

- В файле app1.py накидал все 3 варианта чтобы можно было проверить.


**Ответ для Примера №2.2:** 
```
from flask import Flask, request
import subprocess

app = Flask(name)

@app.route("/dns")
def dns_lookup():
    hostname = request.values.get('hostname')
    cmd = 'nslookup ' + hostname
    output = subprocess.check_output(cmd, shell=True, text=True)
return output
if name == "main":
    app.run(debug=True)
```

- Здесь в строке ``cmd = 'nslookup ' + hostname`` переменная hostname с пользовательского ввода, она никак не валидируется, не экранируется, в нее можно внедрить команду для ОС на нашем веб сервере.
Если к данному коду приметь такие запросы:
```
curl http://localhost:5000/dns?hostname=example.com
curl http://localhost:5000/dns?hostname=example.com%3Bid
curl http://localhost:5000/dns?hostname=example.com%3Bcat%20/etc/passwd
```
то, можно получить информацию с сервера, к которой у нас нет доступа или вообще применить ``rm -rf /*`` тогда вообще удалим файлы с сервера, если права позволят.

**Как исправить**
- Можно экранировать входные данные и валидировать
- Можно использовать ``subprocess.run()`` вместо ``subprocess.check_output()`` и передача команды в виде списка аргументов, а не строки. Передача команды в виде списка аргументов вместо строки предотвращает возможность внедрения произвольных команд через пользовательский ввод (hostname)
- Ограничить права доступа процесса веб-приложения
- Использовать стороние библиотеки, предоставляющих безопасный интерфейс для выполнения команд операционной системы.

Какой вариант точно выбрать не могу сказать, но думаю, что не нужно изобретать велосипед, нужно воспользоваться готовыми решениями против подобных уязвимостей.
В файле ``app2.py`` примеры кода.


---------------------------------------------
#### 3. Часть 3. Моделировани угроз

Сразу по вопросам:
- HTTP или HTTPS ? Внедрить защищенный протокол HTTPS
- Как реализована и настроена Аутентификация и Авторизация? хеширование паролей, защита от атак перебором, использование JWT или других токенов
- Как реализована система доступа? кто куда имеет доступ?
- Как хранятся и обрабатываются чувствительные данные пользователей?
- Как реализованы методы работы с API телеграмми и слака, где хранятся токены?
- Как реализована надлежащая проверка загружаемых файлов, какой загрузчик изображений?
- Раскиданы ли сервисы по контейнерам, как обновляют зависимости?
- Есть ли мониторинг и журналирование?
- Какая защита от внедрения кода и других атак на бекенд-приложение и микрофронт.

Таким оброзом, нужно убедится что:
- между сервисами данные передаються по защищенным протоколам (HTTPS, SSL/TLS);
- реализована современная и безопасная Аутентификация и Авторизация, к примеру через JWT, а также контроль доступа на основе ролей;
- реализовано шифрование для хранения конфиденциальных данных;
- реализована валидация всех входных данных
- реализованы механизмы мониторинга и логирования для своевременного реагирования на угрозы.